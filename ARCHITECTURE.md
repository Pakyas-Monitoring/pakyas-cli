# Pakyas CLI Architecture

> **Note:** This document is intended for contributors and developers who want to understand the internal architecture of the Pakyas CLI. For installation and usage instructions, see [README.md](./README.md).

---

## Multi-Organization Management and Contextual Navigation1. Architectural Philosophy and Strategic PositioningThe design of a Command Line Interface (CLI) for a multi-tenant observability platform like Pakyas represents a complex intersection of user ergonomics, state management, and distributed systems consistency. Unlike graphical interfaces, which offer visual affordances to indicate current state, a CLI operates in a largely stateless textual environment. However, the "pro-tier" developer persona—the primary demographic for Pakyas—demands a tool that balances the speed of stateless automation with the cognitive ease of stateful interaction.1 The architectural challenge, therefore, is to map the rigid hierarchical data model of the platform (Organization > Project > Check) onto the ephemeral nature of terminal sessions without inducing "context drift," where a user inadvertently operates on the wrong resource due to invisible state.2This report defines a comprehensive architecture for the Pakyas CLI, specifically focusing on multi-organization management. It synthesizes best practices from industry leaders like Stripe, Vercel, and Kubernetes, while adapting them to the specific latency and reliability requirements of a cron monitoring system.1 The proposed architecture leverages a "Context-Aware Scope Resolution Protocol," supported by a robust Rust-based implementation using clap, tokio, and keyring.1 This ensures that while the system supports complex multi-tenancy (spanning multiple organizations and projects), the user experience remains linear, predictable, and secure.The core philosophy driving this architecture is "Explicit State, Implicit Convenience." The system must persistently store the user's navigational context (the "Implicit Convenience") to facilitate rapid interactive use, but it must also provide a rigorous mechanism to override this context via global flags (the "Explicit State") to support deterministic scripting and CI/CD workflows.1 This duality allows Pakyas to serve both the solo developer monitoring a handful of jobs and the enterprise DevOps engineer managing thousands of checks across dozens of isolated environments.12. The Hierarchical Data Model and CLI MappingTo understand the CLI's navigational logic, one must first rigorously analyze the underlying data model it manipulates. The Pakyas backend enforces a strict containment hierarchy: Users belong to Organizations; Organizations contain Projects; and Projects contain Checks.1 The CLI architecture must reflect this strict containment in its command structure, state management, and permission validation logic, ensuring referential integrity is maintained at the edge.2.1 The Organization: The Administrative BoundaryThe Organization is the root node of the tenancy model. In the architectural schema defined by the Pakyas Database ERD, the Organization serves as the "hard boundary" for billing, user membership, and high-level policy.1Architectural Definition: An Organization is identified by a UUID and is characterized by an owner_user_id.1 It is the container for org_members, which defines the Role-Based Access Control (RBAC) relationships.1 Crucially, an Organization owns the billing relationship (Stripe Customer ID), meaning that CLI operations that incur costs (like creating checks beyond the free tier) must be validated against the Organization's entitlement state.1CLI Implication: The CLI must treat the Organization as the primary scope for authentication validation. While a User may have a valid JWT, that token's utility is null without a resolved Organization context. The CLI must handle "dangling" states where a user is authenticated but not associated with any Organization (e.g., a newly invited user who hasn't accepted an invite).5 Furthermore, the CLI must act as the first line of defense for RBAC. While the API enforces ultimate security, the CLI must proactively filter commands based on the user's role within the active Organization—for instance, hiding pakyas billing commands from a member with a read-only role in the org_members table.12.2 The Project: The Logical Operations BoundaryBeneath the Organization lies the Project. This layer creates a logical separation often used for environments (e.g., "Production", "Staging") or microservices (e.g., "Payment Service", "Data Pipeline").1Architectural Definition: A Project (project_id) is a direct child of an Organization (org_id).1 It acts as the container for the operational entities: Checks, Integrations, and Status Pages.1 It is the level at which alert routing logic is typically refined; while an Organization sets global defaults, a Project can override specific integration channels (e.g., routing "Staging" alerts to a different Slack channel than "Production").1CLI Implication: The Project layer is the most frequent target for "context switching." A DevOps engineer might spend their morning debugging the "Staging" project and their afternoon monitoring "Production." The CLI architecture must make switching between these lateral contexts instantaneous (pakyas switch staging) without requiring re-authentication or traversing the Organization layer again, provided the Organization context remains constant.6 The CLI must essentially maintain a "cursor" pointing to the active Project ID, which is supplied as a header or path parameter in subsequent API calls.12.3 The Check: The Atomic Unit of MonitoringThe leaf node of the hierarchy is the Check. This represents a single monitored cron job, heartbeat, or scheduled task.1Architectural Definition: A Check (check_id) contains the operational data: schedules (period_seconds, grace_seconds), status (up, down, late), and the immutable log of pings (ping_logs).1 Checks are strictly scoped to a Project. A Check cannot exist outside a Project, nor can it be shared between Projects.1CLI Implication: Checks are the primary noun the user interacts with (pakyas check create, pakyas check logs).1 The architecture must support addressing checks by UUID or by human-readable names. Since names are not guaranteed to be unique across the entire database (only unique within a Project), the CLI relies heavily on the resolved Project context to disambiguate requests. For example, pakyas check get "backup-db" is only a valid command if the CLI knows which Project's backup job is being requested.72.4 Hierarchy Visualization and Command StructureThe CLI command structure mirrors this hierarchy using a Noun-Verb pattern (pakyas <noun> <verb>), which is favored for its discoverability over Verb-Noun patterns in complex systems.9Hierarchy LevelEntityCLI NamespacePrimary OperationsContext DependencyRootUserpakyas authlogin, logout, whoamiGlobal (None)Level 1Organizationpakyas orgcreate, list, switch, inviteUser SessionLevel 2Projectpakyas projectcreate, list, switch, deleteOrganizationLevel 3Checkpakyas checkcreate, list, get, pauseProjectThis structure enforces a mental model where users drill down from broad administrative scopes to specific operational details. The pakyas switch command acts as the elevator moving the user between these levels.63. Context Management ArchitectureThe "Context" is the CLI's specialized memory. It persists the user's navigational state across session boundaries, reducing the cognitive load of repeatedly specifying target resources.11 Without persistent context, a user would be forced to type pakyas check list --org acme --project prod for every interaction, a pattern that degrades usability and increases error rates.123.1 The Configuration Storage Strategy (config.toml)The Pakyas CLI utilizes a TOML-based configuration file, standardized at ~/.config/pakyas/config.toml (adhering to the XDG Base Directory specification on Linux, and appropriate equivalents on macOS/Windows).13 TOML is selected over JSON or YAML for its unambiguous syntax, type safety, and superior support for nested sections, which map cleanly to the hierarchical nature of the profile data.153.1.1 The Profile SchemaThe configuration file is not a flat key-value store; it is a structured database of "Profiles." A Profile represents a named configuration state, including the API endpoint (allowing support for self-hosted instances or staging environments), the user identity, and the default Organization/Project selection.17The schema is defined as follows:Ini, TOML# ~/.config/pakyas/config.toml

# The currently active profile. This determines the default context loaded on startup.
current_profile = "default"

# Global settings apply to the CLI behavior regardless of profile
[global]
update_check = true
output_format = "table" # Options: "table", "json", "yaml"
telemetry = false

# Profile definitions
[profiles.default]
api_url = "https://app.pakyas.com"
user_email = "dev@example.com"
# The UUIDs below represent the persisted context
organization_id = "550e8400-e29b-41d4-a716-446655440000" 
project_id = "770e8400-e29b-41d4-a716-665544002233"
# Token reference key (actual secret is in OS Keyring)
token_ref = "default" 

[profiles.staging_admin]
api_url = "https://staging.pakyas.com"
user_email = "admin@internal.corp"
organization_id = "999e8400-e29b-41d4-a716-888888888888"
# Note: project_id might be missing if not yet selected
token_ref = "staging_admin"
This multi-profile architecture allows a user to maintain distinct contexts for different roles—for example, a "Personal" profile for side projects and a "Work" profile for corporate infrastructure—switching between them with a single command (pakyas profile use work).173.1.2 XDG Compliance and File LocationsTo respect modern Linux and Unix standards, the CLI resolves configuration paths dynamically based on the XDG Base Directory specification.13Config Home ($XDG_CONFIG_HOME): Defaults to ~/.config/pakyas. Stores config.toml.Data Home ($XDG_DATA_HOME): Defaults to ~/.local/share/pakyas. Stores local caches of organization names and project lists to speed up autocomplete and reduce API latency.20State Home ($XDG_STATE_HOME): Defaults to ~/.local/state/pakyas. Stores logs and temporary session data.3.2 The pakyas switch MechanicsThe switch command is the primary mechanism for mutating the current_profile state within the active profile. It is designed to be polymorphic, handling both Organization and Project switching depending on the arguments provided, similar to the behavior observed in the Vercel CLI.63.2.1 Algorithmic Logic of switchWhen a user executes pakyas switch, the CLI enters a "Context Resolution Routine" that handles ambiguity and validates user intent.21Argument Analysis:No Arguments (pakyas switch): The CLI initiates an Interactive Selection Mode. It queries the API (or local cache) for the user's Organizations, displays them using a fuzzy-searchable list (using Rust libraries like dialoguer or inquire 22), and waits for selection. Upon Organization selection, it fetches the Projects within that Org and repeats the selection process for the Project. This is the "Happy Path" for discovery.23One Argument (pakyas switch <name>): The CLI performs an Ambiguity Check. It first searches for an Organization with a matching slug or name. If found, it switches the Org context. If not found, it checks if the argument matches a Project in the current Organization. If a Project match is found, it switches the Project context. If neither is found, or if duplicate names exist, it prompts the user to disambiguate.24Explicit Flags (pakyas switch --org <org> --project <proj>): The verification is direct and non-interactive, suitable for documentation examples and setup scripts.Validation: Before persisting the change, the CLI validates the target. It makes a lightweight API call (e.g., HEAD /api/v1/projects/{id}) to ensure the user has access to the requested resource. This prevents the user from switching into a "broken" context where subsequent commands would fail with 403 Forbidden errors.25Persistence: The config.toml file is updated. The write operation is atomic—the file is written to a temporary location and renamed to prevent corruption during concurrent executions or system crashes.263.3 Context Awareness in PromptingA critical aspect of the UX architecture is "Context Visibility." Cognitive distance theory suggests that users frequently forget their active context, leading to operations being performed on the wrong environment (e.g., deleting a check in Production instead of Staging).2 The Pakyas CLI mitigates this risk through two mechanisms:Active Feedback: Every state-changing command (create, delete, update) outputs the current context in its prologue.Creating check in Org: Acme Corp / Project: Production...Shell Integration: The architecture includes a pakyas completion command that exports shell scripts (Zsh/Bash/Fish) to inject the current Pakyas context into the user's terminal prompt (PS1), similar to kube-ps1 or starship modules.8 This ensures the active context is always in the user's peripheral vision.4. Global Flags and the Override SystemWhile persistent context provides convenience, scripts and power users require determinism. The architecture implements a Global Override Layer that intercepts every command execution to inject state from flags or environment variables, strictly superseding the values in config.toml.274.1 The Configuration Precedence PyramidThe Pakyas CLI adheres to a strict precedence hierarchy, standardized across industry tools like AWS CLI and Terraform.14 This "Pyramid of Precedence" ensures that the most specific instruction always wins.PrioritySourceExampleUse Case1 (Highest)Global Flags--org=acme --project=prodOne-off overrides, explicit scripting.2Environment VariablesPAKYAS_ORG=acmeCI/CD pipelines, containerized runs.3Local Context.pakyas/config.tomlProject-specific config (directory scoped).4User Profile~/.config/pakyas/config.tomlThe default interactive session state.5 (Lowest)Hardcoded Defaultsoutput_format="table"Fallbacks when no config exists.4.2 Global Flag Implementation in RustUsing the clap crate in Rust, these global arguments are defined in a top-level struct that is "flattened" into every subcommand. This ensures that every command in the CLI hierarchy inherits the ability to override context without code duplication.30Rust// Architectural Representation in Rust using clap
#[derive(Parser)]
#[command(name = "pakyas")]
struct Cli {
    #[command(subcommand)]
    command: Commands,

    /// Global Flag: Override the active Organization
    #
    org: Option<String>,

    /// Global Flag: Override the active Project
    #
    project: Option<String>,

    /// Global Flag: JSON, Table, or YAML output
    #[arg(long, global = true, default_value = "table")]
    format: OutputFormat,
}
This architectural pattern, derived from best practices in the Rust CLI ecosystem, ensures type safety and automatic documentation generation.4 When a user runs pakyas check list --project=beta, the clap parser populates the project field in the Cli struct, which the application logic then prioritizes over the loaded config file.324.3 The "Scope Resolver" ComponentThe architecture defines a dedicated ScopeResolver module. This module is invoked at the start of every command execution lifecycle.Input: The raw Cli struct (parsed flags), the System Environment map, and the deserialized Config struct.Process: It merges these inputs according to the precedence pyramid. It resolves names to UUIDs if necessary (checking local cache first, then API).Output: A ResolvedContext object containing the definitive org_id and project_id to be used for the API call.Failure Mode: If the ResolvedContext is incomplete (e.g., the command requires a Project but only an Org is resolved), the ScopeResolver triggers the Interactive Prompter (if a TTY is detected) or raises a MissingContextError (if in non-interactive mode).12 This creates a "Guided Failure" experience where errors become prompts for correction.5. Detailed Command Flow and Navigation ScenariosThe navigation flow is designed to be intuitive, following the "Principle of Least Surprise."5.1 Scenario A: The "Happy Path" (Contextual Navigation)Login: User runs pakyas login. The CLI authenticates via browser and stores the token. It automatically fetches the user's default organization and sets the initial context.33Context Switch: User runs pakyas switch. The TUI presents a list of Orgs. The user selects "My Startup". The TUI then presents projects. User selects "Backend".Operation: User runs pakyas check list.Internal Logic: The CLI reads project_id from config.toml. It executes GET /api/v1/projects/{id}/checks.Output: A formatted table listing checks for the "Backend" project.5.2 Scenario B: The "Power User" Lateral MoveCurrent State: User is in context "My Startup / Backend".Override: User runs pakyas check list --project frontend.Internal Logic: The ScopeResolver detects the --project flag. It ignores the context's project_id. It resolves "frontend" to its UUID. It calls the API with the new ID.Output: Lists checks for "frontend", without changing the persistent context in config.toml. The next command will revert to "Backend".345.3 Scenario C: The "CI/CD" Stateless ExecutionSetup: CI Runner executes export PAKYAS_TOKEN=... and export PAKYAS_PROJECT_ID=....Execution: CI Runner executes pakyas check create --name "Deploy Health" --schedule "*/5 * * * *".Internal Logic: ScopeResolver detects a non-interactive TTY. It finds the required IDs in environment variables. It bypasses the keyring and config file entirely. It executes the creation.Output: JSON response of the created check (due to default CI settings or --format json), which can be piped to jq for validation.356. Security Architecture: Token Storage and LifecycleSecurity in a CLI tool is uniquely challenging because credentials reside on the user's untrusted filesystem. The Pakyas architecture addresses this via a rigorous token lifecycle management strategy, utilizing the system keyring rather than plain-text files.366.1 Secure Token Storage StrategyUnlike the AWS CLI, which notoriously stores long-lived credentials in plain text at ~/.aws/credentials 36, Pakyas adopts the "GitHub CLI model" of using the operating system's native secure storage.37Mechanism: The CLI uses the keyring-rs crate to interface with:macOS: Keychain AccessWindows: Credential ManagerLinux: Secret Service API (GNOME Keyring / KWallet) 37Data Flow: When pakyas login succeeds, the Refresh Token and Access Token are written to the keyring under the service name pakyas-cli. The config.toml only stores a non-sensitive reference (e.g., the user's email) to identifying which keyring entry to use.38Headless Fallback: In CI/CD environments where no display manager or keyring daemon is present, the architecture gracefully degrades to reading the PAKYAS_TOKEN environment variable. This ensures automation is possible without compromising the security of interactive developer workstations.396.2 Token Rotation and Authentication FlowTo maintain enterprise-grade security, the CLI never assumes a token is valid indefinitely. The architecture implements the OAuth 2.0 Authorization Code Flow with PKCE (Proof Key for Code Exchange), which is the standard for public clients like CLIs.41Initiation: pakyas login starts a local web server on a random ephemeral port.Browser Handshake: It opens the system browser to app.pakyas.com/auth/cli. The user authenticates in the browser.Callback: The browser redirects to localhost:{port} with an authorization code.Exchange: The CLI exchanges this code for a Short-Lived Access Token (15-60 minutes) and a Long-Lived Refresh Token (7-30 days).Automatic Refresh: The CLI's HTTP client (built on reqwest) includes middleware that intercepts 401 Unauthorized responses. If a 401 is received, it transparently attempts to use the Refresh Token to acquire a new Access Token, updates the keyring, and retries the original request. This provides a seamless user experience where the user rarely needs to log in manually, despite the short lifespan of the access credentials.417. Comparative Analysis: Pakyas vs. Industry StandardsTo validate the proposed architecture, it is instructive to benchmark it against established industry standards. Pakyas synthesizes the best features of kubectl, gcloud, and vercel while avoiding their usability pitfalls.FeatureGoogle Cloud CLI (gcloud)Kubernetes (kubectl)Vercel CLI (vercel)Pakyas CLIContext Switchingconfig set project (Global State)use-context (Tuples of User/Cluster/NS)link (Directory-based)Hybrid: Global Profile + Local Link + switch commandState VisibilityImplicit (Hidden)Explicit (in prompt via plugins)Implicit (Directory)Explicit: Active feedback headers + Prompt integrationToken StoragePlain Text (Legacy)Plain Text (kubeconfig)Plain Text (auth.json)Secure: OS Keyring (Default) + Env Var (CI)HierarchyProject > ZoneCluster > NamespaceTeam > ProjectOrg > Project > CheckInteractiveLow (Flags mostly)Low (Flags mostly)High (Questions)High: "Guided Failure" leads to promptsAnalysis:vs. gcloud: gcloud suffers from "tab thrashing," where changing the project in one terminal affects all others.42 Pakyas avoids this by allowing directory-scoped configs (.pakyas/config.toml) similar to vercel link, ensuring that a terminal sitting in a "Staging" directory always targets Staging, regardless of the global profile.vs. kubectl: kubectl contexts are powerful but cognitively heavy. Pakyas simplifies the model by enforcing the strict Org > Project hierarchy rather than allowing arbitrary combinations of clusters and users.43vs. vercel: Vercel's link is excellent for code repos but fails for Ops tasks where no local code exists. Pakyas supports link but treats it as an optional override to the global profile, catering to both "Infrastructure-as-Code" and "Ad-hoc Ops" workflows.68. Technical Implementation StrategyThe implementation relies on the Rust ecosystem, chosen for its correctness and performance guarantees. The architecture mandates specific crates to realize the design patterns described above.8.1 The Rust Crate Stackclap (v4+): For argument parsing. The derive feature is used to define the CLI structure in native Rust structs, ensuring that the help documentation (--help) is always synchronized with the code. clap's "flattening" feature is essential for injecting the global --org and --project flags into every subcommand.4tokio: For the async runtime. This is non-negotiable for performance. It allows the CLI to perform parallel health checks (e.g., fetching the status of 50 cron jobs concurrently) and handle the pakyas login local web server implementation.44reqwest: The HTTP client. It is configured with a custom Service middleware to handle the Token Refresh logic described in Section 6.2.config: This crate implements the "Precedence Pyramid." It layers the configuration sources (Environment Variables, Global Config, Local Config) into a single unified Settings struct.18inquire: For interactive prompts. Selected over dialoguer for its superior support for fuzzy searching (essential when selecting one project from a list of 50) and custom type validation (e.g., validating a cron schedule string interactively).48.2 Implementation PatternsThe Scope Struct: A central Rust struct passed to all command handlers. It contains the resolved org_id, project_id, and the authenticated reqwest::Client. It is constructed by a ScopeBuilder that performs the "Context Resolution Routine" before any command logic executes.Error Handling: The CLI uses the thiserror crate for library-level errors and anyhow for application-level error propagation.26 Crucially, the main function creates a "Panic Boundary." No errors are allowed to panic; they are caught and rendered using a custom Display implementation that formats the error in red, provides a "Cause," and most importantly, offers a "Suggestion" (e.g., "Run pakyas login to fix this").449. ConclusionThe Pakyas CLI architecture is designed to be the definitive tool for interacting with the platform, surpassing the Web UI in speed and scriptability. By strictly enforcing the Organization > Project > Check hierarchy through a robust Context Management system, it provides clarity in a multi-tenant environment. By layering Global Overrides on top of this stateful context, it satisfies the duality of interactive ease ("It just works") and automation rigor ("It does exactly what I say").This architecture acknowledges the reality of the "pro-tier" user: they are busy, they manage complex systems, and they switch contexts frequently. By building a tool that remembers where they are (Context), secures their credentials (Keyring), and allows them to override assumptions when necessary (Flags), Pakyas delivers a developer experience that aligns with the high standards of its monitoring backend. The result is a CLI that feels less like a utility script and more like a reliable command center for the user's infrastructure.
